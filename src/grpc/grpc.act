import net
import http2.client

protocol Message:
    @staticmethod
    decode: (bytes) -> Self

    encode: (Self) -> bytes

class ChannelArgumentType:
    pass

class ChannelCredentials:
    pass

class Compression:
    pass

def parse_target(target: str) -> (str, int):
    port_search_start = 0

    if target[0] == '[':
        close_brack_pos = target.find(']', None, None)

        if close_brack_pos > 0:
            port_search_start = close_brack_pos
        else:
            raise Exception("Unclosed bracket in target string")

    colon_pos = target.find(':', port_search_start)

    if colon_pos > -1:
        return target[:colon_pos], int(target[colon_pos+1:])
    else:
        return target, 0

actor Channel(cap: net.TCPConnectCap, target: str, options: list[ChannelArgumentType], credentials: ?ChannelCredentials, compression: ?Compression, on_connect: action(Channel) -> None, on_error: action(Channel, str) -> None):

    host, port = parse_target(target)

    if credentials is None:
        scheme = 'http'
    else:
        scheme = 'https'

    if port == 0:
        if scheme == 'http':
            port = 80
        else:
            port = 443

    def _on_connect(client: http2.client.Http2Client) -> None:
        on_connect(self)

    def _on_error(client: http2.client.Http2Client, error: str) -> None:
        on_error(self, error)

    h2client = http2.client.Http2Client(cap, host, port, _on_connect, _on_error, scheme == 'tls')

    def unary_unary(path: str, message: bytes, on_response: action(Channel) -> bytes):
        
        def _on_headers_recv(c: http2.client.Http2Client, headers: dict[str, str], end_stream: bool):
            pass

        def _on_data_recv(c: http2.client.Http2Client, data: bytes, end_stream: bool):
            pass

        headers = { ':method': 'POST',
                    ':scheme': scheme,
                    ':path': path,
                    'te': 'trailers',
                    'content-type': 'application/grpc' }

        # No compression for now
        compression_bytes = bytes([0x0])

        length = len(message)

        len_bytes = bytes([(length & 0xff000000) >> 24,
                           (length & 0xff0000) >> 16,
                           (length & 0xff00) >> 8, (length & 0xff)])

        data = compression_bytes + len_bytes + message

        stream_id = h2client.start_raw_stream(_on_headers_recv, _on_data_recv)

        h2client.raw_send_headers(stream_id, headers, False)

        h2client.raw_send_data(stream_id, data, True)
